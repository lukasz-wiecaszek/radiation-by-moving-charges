
import numpy as np
import scipy as sp
from datetime import *
from utils import *
from charge import *
from typing import Callable

# The allowable error of the rootâ€™s value in sp.optimize.newton() method
tol = 1e-18

class Fields():

    def __init__(
        self,
        charges: list[Charge]
    ):
        self.charges = charges

    def Eqi(self, q, r, tr):
        """Evaluates the electric field E at the point of observation 'r'
           generated by the individual point charge 'q' at the retarded time 'tr'.

        Parameters
        ----------
        q (Charge) : A charge generating the field
        r (Vector) : Point of observation
        tr (float) : Retarded time of the charge corresponding to the point of observation

        Returns
        -------
        Tuple (unit vector pointing from the charge at the retarded time
        to the point of observation and value of the electric field at that point)

        Notes
        -----
        Please see "Radiation By Moving Charges.pdf,
        chapter 4, 'Fields of a point charge moving with arbitrary velocity'
        and especially equations (4.51, 4.52 and 4.53)."
        """
        r = r - q.position(tr)
        r_magnitude = np.linalg.norm(r)
        v = q.velocity(tr)
        v_magnitude = np.linalg.norm(v)
        a = q.acceleration(tr)
        er = r / r_magnitude
        u = c * er - v
        r_dot_u = np.dot(r, u)
        r_dot_a = np.dot(r, a)
        k = (q.e * r_magnitude) / (4 * pi * eps0 * r_dot_u**3)
        E_coulomb = k * (c**2 - v_magnitude**2) * u
        E_radiation = k * (r_dot_a * u - r_dot_u * a)
        return er, E_coulomb + E_radiation

    def E(self, r, t):
        """Evaluates the electric field E at the point(s) of observation 'r'
           and time 't' generated by the set of point charges (passed in the constructor).

        Parameters
        ----------
        r (Vector | np.array(Vector)) : Point(s) of observation
        t (float) : Time for the evaluation

        Returns
        -------
        Electric field for each point of observation 'r'
        """
        # t1 = datetime.now()
        E = np.zeros_like(r)
        if (r.ndim > 1):
            t = np.full(r.shape[0], t)

        for q in self.charges:
            # First we need to find the retarded time of the charge
            # for each point on the grid
            tr = sp.optimize.newton(
                func = lambda tr, r, t: q.distance(r, tr) - c * (t - tr),
                x0 = t,
                args = (r, t),
                tol = tol)
            if (r.ndim > 1):
                def Eqi(q, r, tr):
                    er, Eqi = self.Eqi(q, r, tr)
                    return Eqi
                E += [Eqi(q, ri, t) for ri, t in zip(r, tr)]
            else:
                er, Eqi = self.Eqi(q, r, tr)
                E += Eqi

        # t2 = datetime.now()
        # print("E: " + str(t2 - t1))
        return E

    def B(self, r, t):
        """Evaluates the magnetic field B at the point(s) of observation 'r'
           and time 't' generated by the set of point charges (passed in the constructor).

        Parameters
        ----------
        r (Vector | np.array(Vector)) : Point(s) of observation
        t (float) : Time for the evaluation

        Returns
        -------
        Magnetic field for each point of observation 'r'
        """
        # t1 = datetime.now()
        B = np.zeros_like(r)
        if (r.ndim > 1):
            t = np.full(r.shape[0], t)

        for q in self.charges:
            # First we need to find the retarded time of the charge
            # for each point on the grid
            tr = sp.optimize.newton(
                func = lambda tr, r, t: q.distance(r, tr) - c * (t - tr),
                x0 = t,
                args = (r, t),
                tol = tol)

            if (r.ndim > 1):
                def Bqi(q, r, tr):
                    er, Eqi = self.Eqi(q, r, tr)
                    return np.cross(er, Eqi) / c
                B += [Bqi(q, ri, t) for ri, t in zip(r, tr)]
            else:
                er, Eqi = self.Eqi(q, r, tr)
                B += np.cross(er, Eqi) / c

        # t2 = datetime.now()
        # print("B: " + str(t2 - t1))
        return B

    def S(self, r, t):
        """Evaluates the Poynting vector S field at the point(s) of observation 'r'
           and time 't' generated by the set of point charges (passed in the constructor).

        Parameters
        ----------
        r (Vector | np.array(Vector)) : Point(s) of observation
        t (float) : Time for the evaluation

        Returns
        -------
        Poynting vector for each point of observation 'r'
        """
        # t1 = datetime.now()
        S = np.zeros_like(r)
        if (r.ndim > 1):
            t = np.full(r.shape[0], t)

        for q in self.charges:
            # First we need to find the retarded time of the charge
            # for each point on the grid
            tr = sp.optimize.newton(
                func = lambda tr, r, t: q.distance(r, tr) - c * (t - tr),
                x0 = t,
                args = (r, t),
                tol = tol)

            if (r.ndim > 1):
                def Sqi(q, r, tr):
                    er, Eqi = self.Eqi(q, r, tr)
                    return np.cross(Eqi , np.cross(er, Eqi)) / (c * mu0)
                S += [Sqi(q, ri, t) for ri, t in zip(r, tr)]
            else:
                er, Eqi = self.Eqi(q, r, tr)
                S += np.cross(Eqi , np.cross(er, Eqi)) / (c * mu0)

        # t2 = datetime.now()
        # print("S: " + str(t2 - t1))
        return S
